#!r6rs
;; Copyright 2009 Derick Eddington.  My MIT-style license is in the file named
;; LICENSE from the original collection this file is distributed with.

(import
  (rnrs)
  (xitomatl predicates)
  (srfi :78 lightweight-testing)
  (only (xitomatl exceptions) catch))

(define-syntax check-AV
  (syntax-rules ()
    ((_ expr)
     (check (catch ex ((else (assertion-violation? ex)))
              expr
              'unexpected-return)
            => #T))))

;;;; not?
(check ((not? string?) 1) => #T)
(check ((not? vector?) '#()) => #F)
;;;; and?
(check ((and?) 1) => #T)
(check ((and? integer?) 1) => #T)
(check ((and? string?) 1) => #F)
(check ((and? string->symbol) "foo") => 'foo)
(check ((and? list? null?) '()) => #T)
(check ((and? number? real?) 9+8i) => #F)
(check ((and? pair? reverse) '(a b c)) => '(c b a))
(check ((and? integer? exact? (not? negative?)) 42) => #T)
(check ((and? integer? exact? (not? negative?)) -42) => #F)
(check ((and? integer? exact? (not? negative?)) 42.0) => #F)
(check ((and? integer? exact? (not? negative?)) 'foo) => #F)
(check ((and? integer? exact? -) -42) => 42)
(check ((apply and? char? (list char-alphabetic? (lambda (_) #T) values))
        #\c)
       => #\c)
(let ((x '()))
  (check ((and? (lambda (_) (set! x (cons 'a x)) #F)
                (lambda (_) (set! x (cons 'b x)) #T)
                (lambda (_) (set! x (cons 'c x)) #T)
                (lambda (_) (set! x (cons 'd x)) #T))
          'foo)
         => #F)
  (check x => '(a)))
(let ((x '()))
  (check ((and? (lambda (_) (set! x (cons 'a x)) #T)
                (lambda (_) (set! x (cons 'b x)) #T)
                (lambda (_) (set! x (cons 'c x)) #F)
                (lambda (_) (set! x (cons 'd x)) #F))
          'foo)
         => #F)
  (check x => '(c b a)))
(let ((x '()))
  (check ((and? (lambda (_) (set! x (cons 'a x)) #T)
                (lambda (_) (set! x (cons 'b x)) #T)
                (lambda (_) (set! x (cons 'c x)) #T)
                (lambda (_) (set! x (cons 'd x)) 'R))
          'foo)
         => 'R)
  (check x => '(d c b a)))
;;;; or?
(check ((or?) 1) => #F)
(check ((or? integer?) 1) => #T)
(check ((or? string?) 1) => #F)
(check ((or? symbol->string) 'foo) => "foo")
(check ((or? string? list?) '(foo)) => #T)
(check ((or? string? list?) "foo") => #T)
(check ((or? string? list?) 1) => #F)
(check ((or? list? null?) '()) => #T)
(check ((or? cadr reverse) '(a b c)) => 'b)
(check ((or? integer? exact? (not? negative?)) 1.2) => #T)
(check ((or? integer? exact? (not? negative?)) -9/8) => #T)
(check ((or? integer? exact? (not? negative?)) -1.0) => #T)
(check ((or? integer? exact? (not? negative?)) -1.2) => #F)
(check ((or? integer? - exact?) 1.2) => -1.2)
(check ((apply or? flonum? (list fixnum? number? values))
        'foo)
       => 'foo)
(let ((x '()))
  (check ((or? (lambda (_) (set! x (cons 'a x)) #F)
               (lambda (_) (set! x (cons 'b x)) #F)
               (lambda (_) (set! x (cons 'c x)) #F)
               (lambda (_) (set! x (cons 'd x)) #F))
          'foo)
         => #F)
  (check x => '(d c b a)))
(let ((x '()))
  (check ((or? (lambda (_) (set! x (cons 'a x)) 'R)
               (lambda (_) (set! x (cons 'b x)) #F)
               (lambda (_) (set! x (cons 'c x)) #F)
               (lambda (_) (set! x (cons 'd x)) #F))
          'foo)
         => 'R)
  (check x => '(a)))
(let ((x '()))
  (check ((or? (lambda (_) (set! x (cons 'a x)) #F)
               (lambda (_) (set! x (cons 'b x)) 'R)
               (lambda (_) (set! x (cons 'c x)) #T)
               (lambda (_) (set! x (cons 'd x)) #F))
          'foo)
         => 'R)
  (check x => '(b a)))
;;;; xor?
(check ((xor?) 1) => #F)
(check ((xor? integer?) 1) => #T)
(check ((xor? string?) 1) => #F)
(check ((xor? number->string) 1) => "1")
(check ((xor? string? list?) '(foo)) => #T)
(check ((xor? string? list?) "foo") => #T)
(check ((xor? string? list?) 1) => #F)
(check ((xor? list? null?) '()) => #F)
(check ((xor? cadr null?) '(a b c)) => 'b)
(check ((xor? null? caddr) '(a b c)) => 'c)
(check ((xor? integer? exact? (not? negative?)) 1.2) => #T)
(check ((xor? integer? exact? (not? negative?)) 1) => #F)
(check ((xor? integer? exact? (not? negative?)) 1.0) => #F)
(check ((xor? integer? exact? (not? negative?)) -1.2) => #F)
(check ((xor? / string? inexact?) 2) => 1/2)
(check ((xor? integer? - exact?) 1.2) => -1.2)
(check ((xor? integer? complex? string->number) "2") => 2)
(check ((apply xor? null? (list string-length pair? symbol?))
        "foo")
       => 3)
(let ((x '()))
  (check ((xor? (lambda (_) (set! x (cons 'a x)) #F)
                (lambda (_) (set! x (cons 'b x)) #F)
                (lambda (_) (set! x (cons 'c x)) #F)
                (lambda (_) (set! x (cons 'd x)) #F))
          'foo)
         => #F)
  (check x => '(d c b a)))
(let ((x '()))
  (check ((xor? (lambda (_) (set! x (cons 'a x)) #F)
                (lambda (_) (set! x (cons 'b x)) 'R)
                (lambda (_) (set! x (cons 'c x)) #F)
                (lambda (_) (set! x (cons 'd x)) #F))
          'foo)
         => 'R)
  (check x => '(d c b a)))
(let ((x '()))
  (check ((xor? (lambda (_) (set! x (cons 'a x)) #F)
                (lambda (_) (set! x (cons 'b x)) #T)
                (lambda (_) (set! x (cons 'c x)) #T)
                (lambda (_) (set! x (cons 'd x)) #F))
          'foo)
         => #F)
  (check x => '(c b a)))
;; non-negative-integer?
(check (non-negative-integer? "no") => #F)
(check (non-negative-integer? 1/2) => #F)
(check (non-negative-integer? -2) => #F)
(check (non-negative-integer? 0) => #T)
(check (non-negative-integer? 321) => #T)
(check (non-negative-integer? 7.0) => #T)
;; exact-non-negative-integer?
(check (exact-non-negative-integer? #\z) => #F)
(check (exact-non-negative-integer? 0.0) => #F)
(check (exact-non-negative-integer? 45.0) => #F)
(check (exact-non-negative-integer? -34) => #F)
(check (exact-non-negative-integer? 0) => #T)
(check (exact-non-negative-integer? 89348) => #T)
;; positive-integer?
(check (positive-integer? '(nope)) => #F)
(check (positive-integer? 0) => #F)
(check (positive-integer? -34) => #F)
(check (positive-integer? 789/23) => #F)
(check (positive-integer? 85.0) => #T)
(check (positive-integer? 3916237) => #T)
;; exact-positive-integer?
(check (exact-positive-integer? '#()) => #F)
(check (exact-positive-integer? 21.0) => #F)
(check (exact-positive-integer? -9) => #F)
(check (exact-positive-integer? 3.21) => #F)
(check (exact-positive-integer? 1) => #T)
(check (exact-positive-integer? 567/1) => #T)
;; exact-integer?
(check (exact-integer? '()) => #F)
(check (exact-integer? 1.0) => #F)
(check (exact-integer? 3/2) => #F)
(check (exact-integer? 0) => #T)
(check (exact-integer? -76) => #T)
(check (exact-integer? 238) => #T)
;; list-of?
(check ((list-of? string?) '()) => #T)
(check ((list-of? string?) 'foo) => #F)
(check ((list-of? number?) '(-45/6 23.71)) => #T)
(check ((list-of? (lambda (x) #F)) '(hehe)) => #F)
(check ((list-of? char?) '(#\a #\b "c" #\d)) => #F)
;; pairwise?
(define pw< (pairwise? <))
(check (pw<) => #T)
(check (pw< 42) => #T)
(check (pw< -.4e2 -4/5 0 (* 2 (greatest-fixnum))) => #T)
(check (pw< 0 -1 1) => #F)
(check (list-sort pw< '(56 -5/2 0.0 -1234.)) => (list-sort < '(56 -5/2 0.0 -1234.)))
(define pw>= (pairwise? >=))
(check (pw>= 5.0 5 49/10 4.8 1 1 0) => #T)
(check (pw>= 1 2) => #F)
(check (list-sort pw>= '(56 -5/2 -1234.)) => (list-sort >= '(56 -5/2 -1234.)))
(define-record-type thing (fields a))
(define pw-thing=? (pairwise? equal?
                    (lambda (x)
                      (if (thing? x)
                        (thing-a x)
                        (assertion-violation 'pw-thing=? "invalid" x)))))
(check (pw-thing=?) => #T)
(check (pw-thing=? (make-thing 1)) => #T)
(check (pw-thing=?) => #T)
(check (apply pw-thing=? (map make-thing '(o o o))) => #T)
(check (apply pw-thing=? (map make-thing '(o o o z))) => #F)
(check-AV (pw-thing=? 'oops))
(check-AV (pw-thing=? (make-thing 1) 'oops))
(let ((a '()))
  (define pw (pairwise? (lambda (x y) #T)
                        (lambda (x)
                          (set! a (append a (list x)))
                          x)))
  (pw 'a 'b 'c 'd 'e 'f 'g)
  ;; user's proc is called only once per element, in sequence
  (check a => '(a b c d e f g)))
;; symbol<?
(check (symbol<?) => #T)
(check (symbol<? 'foo) => #T)
(check (symbol<? 'blah 'asdf) => #F)
(check (symbol<? 'f 'h) => #T)
(check (symbol<? 'aaa 'aab 'ab 'ba 'br 'ha 'zdsf) => #T)
(check-AV (symbol<? "oops"))
(check-AV (symbol<? 'foo ''oops 'bar))
;; name=?
(check (name=?) => #T)
(check (name=? "foo") => #T)
(check (name=? #'foo 'foo) => #T)
(check (name=? #'foo 'foo "foo" #'foo "foo" 'foo) => #T)
(check (name=? #'foo 'bar) => #F)
(check (name=? "foo" #'foo 'foo 'bar) => #F)
(check-AV (name=? 1))
(check-AV (name=? 'foo ''oops 'bar))
;; non-empty-string?
(check (non-empty-string? 'nope) => #F)
(check (non-empty-string? "") => #F)
(check (non-empty-string? "a") => #T)
(check (non-empty-string? "blah asdf zab") => #T)
;; char-line-ending?
(check (char-line-ending? 'nope) => #F)
(check (char-line-ending? #\a) => #F)
(check (char-line-ending? #\xa) => #T)
(check (char-line-ending? #\xd) => #T)
(check (char-line-ending? #\x85) => #T)
(check (char-line-ending? #\x2028) => #T)


(check-report)
