;; Copyright (c) 2009 Derick Eddington.  All rights reserved.  Licensed under an
;; MIT-style license.  My license is in the file named LICENSE from the original
;; collection this file is distributed with.  If this file is redistributed with
;; some other collection, my license must also be included.

#!r6rs
(import
  (rnrs)
  (srfi :78 lightweight-testing)
  (srfi :39 parameters)
  (only (xitomatl lists) sublist)
  (for (only (xitomatl indexes) enumerate) expand)
  (xitomatl irregex)
  (xitomatl irregex extras)
  (xitomatl irregex counting))

(define-syntax check-AV
  (syntax-rules ()
    [(_ expr)
     (check (guard (ex [else (assertion-violation? ex)])
              expr
              'unexpected-return)
            => #t)]))

(define-syntax check-values
  (syntax-rules (=>)
    ((_ expr => vals ...)
     (check (let-values ((v expr)) v) => (list vals ...)))))

;;;; line-separators

(check (line-separators)
       => '("\xA;" "\xD;" "\xD;\xA;" "\x85;" "\xC;" "\x2028;" "\x2029;"))
(check-AV (line-separators 'oops))
(check-AV (line-separators '("ab" "cd" oops)))
(check-AV (line-separators '("ab" "c" "" "d")))
(check-AV (line-separators '("ab" "c" "xyz" "d")))
(parameterize ((line-separators '("ab" "c" "xy" "d")))
  (check (line-separators) => '("ab" "c" "xy" "d")))
(parameterize ((line-separators '()))
  (check-values (chunk-counts list-chunker '("a\nbc\rdef\r\nghi") 13 0 0 0 0)
                => 13 0 13 0 '()))

;;;; chunk-counts

(let-syntax
    ((test
      (syntax-rules (=>)
        ((_ chunk pos (char line column offset) => (c l col o ((ls le) ...)))
         (check-values (chunk-counts
                        range-list-chunker chunk pos char line column offset)
                       => c l col o (list (cons ls le) ...))))))
  (test '("abcdef" 0 6) 0 (0 0 0 0) => (0 0 0 0 ()))
  (test '("abcdef" 0 6) 0 (1 0 1 0) => (1 0 1 0 ()))
  (test '("abcdef" 0 6) 1 (0 0 0 0) => (1 0 1 0 ()))
  (test '("abcdef" 0 6) 1 (1 0 1 0) => (2 0 2 0 ()))
  (test '("abcdef" 0 6) 6 (1 0 1 0) => (7 0 7 0 ()))
  (test '("abcdef" 1 5) 1 (0 0 0 0) => (0 0 0 0 ()))
  (test '("abcdef" 2 4) 2 (1 0 1 0) => (1 0 1 0 ()))
  (test '("abcdef" 2 4) 3 (1 0 1 0) => (2 0 2 0 ()))
  (test '("abcdef" 1 5) 5 (0 0 0 0) => (4 0 4 0 ()))
  (test '("abc\ndef" 0 6) 0 (0 0 0 0) => (0 0 0 0 ()))
  (test '("abc\ndef" 0 6) 1 (0 0 0 0) => (1 0 1 0 ()))
  (test '("abc\ndef" 0 6) 2 (0 0 0 0) => (2 0 2 0 ()))
  (test '("abc\ndef" 0 6) 3 (0 0 0 0) => (3 0 3 0 ()))
  (test '("abc\ndef" 0 6) 4 (0 0 0 0) => (4 1 0 0 ((3 4))))
  (test '("abc\ndef" 0 6) 5 (0 0 0 0) => (5 1 1 0 ((3 4))))
  (test '("abc\ndef" 0 6) 6 (0 0 0 0) => (6 1 2 0 ((3 4))))
  (test '("abc\ndef" 1 5) 1 (0 0 0 0) => (0 0 0 0 ()))
  (test '("abc\ndef" 1 5) 2 (0 0 0 0) => (1 0 1 0 ()))
  (test '("abc\ndef" 1 5) 3 (0 0 0 0) => (2 0 2 0 ()))
  (test '("abc\ndef" 1 5) 4 (0 0 0 0) => (3 1 0 0 ((3 4))))
  (test '("abc\ndef" 1 5) 5 (0 0 0 0) => (4 1 1 0 ((3 4))))
  (test '("abc\ndef" 2 4) 2 (0 0 0 0) => (0 0 0 0 ()))
  (test '("abc\ndef" 2 4) 3 (0 0 0 0) => (1 0 1 0 ()))
  (test '("abc\ndef" 2 4) 4 (0 0 0 0) => (2 1 0 0 ((3 4))))
  (test '("abc\ndef\nghi" 0 11) 6 (0 0 0 0) => (6 1 2 0 ((3 4))))
  (test '("abc\ndef\nghi" 0 11) 7 (0 0 0 0) => (7 1 3 0 ((3 4))))
  (test '("abc\ndef\nghi" 0 11) 8 (0 0 0 0) => (8 2 0 0 ((3 4) (7 8))))
  (test '("abc\ndef\nghi" 0 11) 9 (0 0 0 0) => (9 2 1 0 ((3 4) (7 8))))
  (test '("abc\ndef\nghi" 0 11) 10 (0 0 0 0) => (10 2 2 0 ((3 4) (7 8))))
  (test '("abc\ndef\nghi" 0 11) 11 (0 0 0 0) => (11 2 3 0 ((3 4) (7 8))))
  (test '("abc\ndef\nghi" 2 9) 6 (0 0 0 0) => (4 1 2 0 ((3 4))))
  (test '("abc\ndef\nghi" 2 9) 7 (0 0 0 0) => (5 1 3 0 ((3 4))))
  (test '("abc\ndef\nghi" 2 9) 8 (0 0 0 0) => (6 2 0 0 ((3 4) (7 8))))
  (test '("abc\ndef\nghi" 2 9) 9 (0 0 0 0) => (7 2 1 0 ((3 4) (7 8))))
  (test '("abc\n\ndef\n\n\nghi" 0 14) 4 (0 0 0 0) => (4 1 0 0 ((3 4))))
  (test '("abc\n\ndef\n\n\nghi" 0 14) 5 (0 0 0 0) => (5 2 0 0 ((3 4) (4 5))))
  (test '("abc\n\ndef\n\n\nghi" 0 14) 7 (0 0 0 0) => (7 2 2 0 ((3 4) (4 5))))
  (test '("abc\n\ndef\n\n\nghi" 0 14) 9 (0 0 0 0) => (9 3 0 0 ((3 4) (4 5) (8 9))))
  (test '("abc\n\ndef\n\n\nghi" 0 14) 10 (0 0 0 0)
        => (10 4 0 0 ((3 4) (4 5) (8 9) (9 10))))
  (test '("abc\n\ndef\n\n\nghi" 0 14) 11 (0 0 0 0)
        => (11 5 0 0 ((3 4) (4 5) (8 9) (9 10) (10 11))))
  (test '("abc\n\ndef\n\n\nghi" 0 14) 12 (0 0 0 0)
        => (12 5 1 0 ((3 4) (4 5) (8 9) (9 10) (10 11))))
  (test '("\nbcdef" 0 6) 0 (123 45 67 0) => (123 45 67 0 ()))
  (test '("\nbcdef" 0 6) 0 (123 45 0 1) => (123 45 0 1 ((#F 1))))
  (test '("\nbcdef" 0 6) 1 (123 45 67 0) => (124 46 0 0 ((0 1))))
  (test '("\nbcdef" 0 6) 1 (123 45 0 1) => (124 45 0 0 ((#F 1))))
  (test '("\nbcdef" 0 6) 2 (123 45 67 0) => (125 46 1 0 ((0 1))))
  (test '("\nbcdef" 0 6) 2 (123 45 0 1) => (125 45 1 0 ((#F 1))))
  (test '("\nbcdef" 0 6) 6 (123 45 67 0) => (129 46 5 0 ((0 1))))
  (test '("\nbcdef" 0 6) 6 (123 45 0 1) => (129 45 5 0 ((#F 1))))
  (test '("a\nbcdef" 1 5) 1 (123 45 67 0) => (123 45 67 0 ()))
  (test '("a\nbcdef" 1 5) 1 (123 45 0 1) => (123 45 0 1 ((#F 2))))
  (test '("ab\ncdef" 2 4) 3 (123 45 67 0) => (124 46 0 0 ((2 3))))
  (test '("ab\ncdef" 2 4) 3 (123 45 0 1) => (124 45 0 0 ((#F 3))))
  (test '("ab\ncdef" 2 4) 4 (123 45 67 0) => (125 46 1 0 ((2 3))))
  (test '("ab\ncdef" 2 4) 4 (123 45 0 1) => (125 45 1 0 ((#F 3))))
  (test '("abcdef\n" 0 7) 6 (0 0 0 0) => (6 0 6 0 ()))
  (test '("abcdef\n" 0 7) 7 (0 0 0 0) => (7 1 0 0 ((6 7))))
  (test '("abc\r" 0 4 "\ndef" 0 4) 0 (0 0 0 0) => (0 0 0 0 ()))
  (test '("abc\r" 0 4 "\ndef" 0 4) 1 (0 0 0 0) => (1 0 1 0 ()))
  (test '("abc\r" 0 4 "\ndef" 0 4) 2 (0 0 0 0) => (2 0 2 0 ()))
  (test '("abc\r" 0 4 "\ndef" 0 4) 3 (0 0 0 0) => (3 0 3 0 ()))
  (test '("abc\r" 0 4 "\ndef" 0 4) 4 (0 0 0 0) => (4 1 0 1 ((3 #F))))
  (test '("abc\rx" 1 4 "x\ndef" 1 4) 1 (0 0 0 0) => (0 0 0 0 ()))
  (test '("abc\rx" 1 4 "x\ndef" 1 4) 2 (0 0 0 0) => (1 0 1 0 ()))
  (test '("abc\rx" 1 4 "x\ndef" 1 4) 3 (0 0 0 0) => (2 0 2 0 ()))
  (test '("abc\rx" 1 4 "x\ndef" 1 4) 4 (0 0 0 0) => (3 1 0 1 ((3 #F))))
  (test '("ab\rxx" 2 3 "xx\ncd" 2 3) 2 (0 0 0 0) => (0 0 0 0 ()))
  (test '("ab\rxx" 2 3 "xx\ncd" 2 3) 3 (0 0 0 0) => (1 1 0 1 ((2 #F))))
  (test '("abc\ndef\r" 0 8 "\nghi" 0 4) 6 (0 0 0 0) => (6 1 2 0 ((3 4))))
  (test '("abc\ndef\r" 0 8 "\nghi" 0 4) 7 (0 0 0 0) => (7 1 3 0 ((3 4))))
  (test '("abc\ndef\r" 0 8 "\nghi" 0 4) 8 (0 0 0 0) => (8 2 0 1 ((3 4) (7 #F))))
  (test '("abc\ndef\rxx" 2 8 "x\nghi" 1 4) 6 (0 0 0 0) => (4 1 2 0 ((3 4))))
  (test '("abc\ndef\rxx" 2 8 "x\nghi" 1 4) 7 (0 0 0 0) => (5 1 3 0 ((3 4))))
  (test '("abc\ndef\rxx" 2 8 "x\nghi" 1 4) 8 (0 0 0 0) => (6 2 0 1 ((3 4) (7 #F))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 0 (123 45 67 0) => (123 45 67 0 ()))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 0 (123 45 0 1) => (123 45 0 1 ((#F 1))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 1 (123 45 67 0) => (124 46 0 0 ((0 1))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 1 (123 45 0 1) => (124 45 0 0 ((#F 1))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 2 (123 45 67 0) => (125 46 1 0 ((0 1))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 2 (123 45 0 1) => (125 45 1 0 ((#F 1))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 3 (123 45 67 0) => (126 47 0 1 ((0 1) (2 4))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 3 (123 45 0 1) => (126 46 0 1 ((#F 1) (2 4))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 4 (123 45 67 0) => (127 47 0 0 ((0 1) (2 4))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 4 (123 45 0 1) => (127 46 0 0 ((#F 1) (2 4))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 5 (123 45 67 0) => (128 47 1 0 ((0 1) (2 4))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 5 (123 45 0 1) => (128 46 1 0 ((#F 1) (2 4))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 6 (123 45 67 0)
        => (129 48 0 0 ((0 1) (2 4) (5 6))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 6 (123 45 0 1)
        => (129 47 0 0 ((#F 1) (2 4) (5 6))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 7 (123 45 67 0)
        => (130 48 1 0 ((0 1) (2 4) (5 6))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 7 (123 45 0 1)
        => (130 47 1 0 ((#F 1) (2 4) (5 6))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 8 (123 45 67 0)
        => (131 49 0 1 ((0 1) (2 4) (5 6) (7 #F))))
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 8 (123 45 0 1)
        => (131 48 0 1 ((#F 1) (2 4) (5 6) (7 #F))))
  (test '("a\nb\r\nc\fd\r" 1 4 "\nef" 0 3) 1 (123 45 67 0) => (123 45 67 0 ()))
  (test '("a\nb\r\nc\fd\r" 1 4 "\nef" 0 3) 1 (123 45 0 1) => (123 45 0 1 ((#F 2))))
  (test '("a\nb\r\nc\fd\r" 1 4 "\nef" 0 3) 2 (123 45 67 0) => (124 46 0 0 ((1 2))))
  (test '("a\nb\r\nc\fd\r" 1 4 "\nef" 0 3) 2 (123 45 0 1) => (124 45 0 0 ((#F 2))))
  (test '("a\nb\r\nc\fd\r" 1 4 "\nef" 0 3) 3 (123 45 67 0) => (125 46 1 0 ((1 2))))
  (test '("a\nb\r\nc\fd\r" 1 4 "\nef" 0 3) 3 (123 45 0 1) => (125 45 1 0 ((#F 2))))
  (test '("a\nb\r\nc\fd\r" 1 4 "\nef" 0 3) 4 (123 45 67 0)
        => (126 47 0 1 ((1 2) (3 #F))))
  (test '("a\nb\r\nc\fd\r" 1 4 "\nef" 0 3) 4 (123 45 0 1)
        => (126 46 0 1 ((#F 2) (3 #F))))
  (test '("a" 0 1 "b" 0 1) 0 (0 0 0 0) => (0 0 0 0 ()))
  (test '("a" 0 1 "b" 0 1) 1 (0 0 0 0) => (1 0 1 0 ()))
  (test '("a" 0 1 "\n" 0 1) 0 (0 0 0 0) => (0 0 0 0 ()))
  (test '("a" 0 1 "\n" 0 1) 1 (0 0 0 0) => (1 0 1 0 ()))
  (test '("\n" 0 1 "b" 0 1) 0 (0 0 0 0) => (0 0 0 0 ()))
  (test '("\n" 0 1 "b" 0 1) 1 (0 0 0 0) => (1 1 0 0 ((0 1))))
  (test '("\r" 0 1 "\n" 0 1) 0 (0 0 0 0) => (0 0 0 0 ()))
  (test '("\r" 0 1 "\n" 0 1) 1 (0 0 0 0) => (1 1 0 1 ((0 #F))))
  (test '("ab" 0 2 "cd" 0 2 . break-if-not-ignored) 1 (0 0 0 0) => (1 0 1 0 ()))
  (parameterize ((line-separators '("ZZ" "X")))
    (test '("abc\ndef" 0 6) 5 (0 0 0 0) => (5 0 5 0 ()))
    (test '("X\nbZZ\rX\ncX\fd\rZ" 0 14 "Z\nef" 0 3) 8 (123 45 67 0)
          => (131 48 1 0 ((0 1) (3 5) (6 7))))
    (test '("Z\nbZZ\rX\ncX\fd\rZ" 0 14 "Z\nef" 0 3) 14 (123 45 0 1)
          => (137 49 0 1 ((#F 1) (3 5) (6 7) (9 10) (13 #F)))))
  ;; correctly reset after parameterization
  (test '("\nb\r\nc\fd\r" 0 8 "\nef" 0 3) 8 (123 45 0 1)
        => (131 48 0 1 ((#F 1) (2 4) (5 6) (7 #F)))))

;;;; counted chunking

(define text0
  '("..Alpha Αα\xA;.." 2 11
    "Beta Ββ" 0 7
    "...\xD;Gamma Γγ\xD;." 3 13
    ".\xA;Delta Δδ\x85;Epsilon Εε\xC;Zeta" 1 26
    " Ζζ\x2028;Eta Ηη\x2029;Theta Θθ..." 0 19
    ".\xA;Iota Ιι\xD;Kappa Κκ\xD;\xA;." 1 20
    "Lambda Λλ\x85;Mu Μμ\xC;Nu Νν" 0 21
    "..\x2028;Xi Ξξ\x2029;Omicron Οο\xA;Pi Ππ\xD;...." 2 26
    ".....Rho Ρρ.." 5 11
    "\xD;\xA;Sigma Σσς\x85;..." 0 12
    "Tau Ττ." 0 6
    "\xC;" 0 1
    "..Upsilon Υυ\x2028;Phi Φφ\x2029;." 2 20
    ".Chi Χχ\xA;Psi Ψψ\xD;Omega Ωω\xD;" 1 24
    "\xA;" 0 1))

;; sanity check
(check (let ((m (irregex-match/chunked '(* any) range-list-chunker text0)))
         (and m (irregex-match-substring m)))
       => "Alpha Αα\xA;Beta Ββ\xD;Gamma Γγ\xD;\xA;Delta Δδ\x85;Epsilon Εε\xC;Zeta Ζζ\x2028;Eta Ηη\x2029;Theta Θθ\xA;Iota Ιι\xD;Kappa Κκ\xD;\xA;Lambda Λλ\x85;Mu Μμ\xC;Nu Νν\x2028;Xi Ξξ\x2029;Omicron Οο\xA;Pi Ππ\xD;Rho Ρρ\xD;\xA;Sigma Σσς\x85;Tau Ττ\xC;Upsilon Υυ\x2028;Phi Φφ\x2029;Chi Χχ\xA;Psi Ψψ\xD;Omega Ωω\xD;\xA;")

(define icc0 (counted-chunking-make-initial-chunk range-list-chunker text0))
(check (counted-chunk? icc0) => #T)
(check (counted-chunk-underlying icc0) (=> eq?) text0)
(check (counted-chunk-char icc0) => 0)
(check (counted-chunk-line icc0) => 0)
(check (counted-chunk-column icc0) => 0)
(check (counted-chunk-offset icc0) => 0)
(check (counted-chunk-next icc0) => #F)

(define ccr0 (counted-chunking-make-chunker range-list-chunker))
(check ((chunker-get-str ccr0) icc0) => (car text0))
(check ((chunker-get-start ccr0) icc0) => (cadr text0))
(check ((chunker-get-end ccr0) icc0) => (caddr text0))
(check (chunker-get-subchunk ccr0) => #F)
(let ((n ((chunker-get-next ccr0) icc0)))
  (check (counted-chunk? n) => #T)
  (check (counted-chunk-next icc0) (=> eq?) n)
  (check ((chunker-get-next ccr0) icc0) (=> eq?) n)
  (check ((chunker-get-str ccr0) n) => (car (cdddr text0)))
  (check ((chunker-get-start ccr0) n) => (cadr (cdddr text0)))
  (check ((chunker-get-end ccr0) n) => (caddr (cdddr text0)))
  (check ((chunker-get-substring ccr0) icc0 4 n 3) => "pha Αα\xA;Bet"))

(define (positions cc)
  (list (counted-chunk-char cc) (counted-chunk-line cc)
        (counted-chunk-column cc) (counted-chunk-offset cc)))
(define (all-positions ccr)
  (let ((get-next (chunker-get-next ccr)))
    (lambda (icc)
      (let loop ((c icc) (l '()))
        (if c
          (loop (get-next c) (cons (positions c) l))
          (reverse l))))))

(check ((all-positions ccr0) icc0)
       => '((0 0 0 0)
            (9 1 0 0)
            (16 1 7 0)
            (26 3 0 1)
            (51 5 4 0)
            (70 7 8 0)
            (89 10 0 0)
            (110 12 5 0)
            (134 16 0 0)
            (140 16 6 0)
            (152 18 0 0)
            (158 18 6 0)
            (159 19 0 0)
            (177 21 0 0)
            (200 24 0 1)))

(let* ((last-counted-chunk
        (lambda (cc)
          (let loop ((cc cc))
            (let ((n (counted-chunk-next cc)))
              (if n (loop n) cc)))))
       (get-next (chunker-get-next ccr0))
       (last (last-counted-chunk icc0)))
  (assert (not (eq? last icc0)))
  (check (list (get-next last) (get-next last) (get-next last))
         => '(#F #F #F)))


(let ((ac 0) (bc 0) (cc 0))
  (let* ((c (list "ccc"))
         (b (cons "bb" c))
         (a (cons "a" b))
         (i (counted-chunking-make-initial-chunk list-chunker a)))
    (let* ((u-get-next (lambda (x)
                         (cond ((eq? x a) (set! ac (+ 1 ac)))
                               ((eq? x b) (set! bc (+ 1 bc)))
                               ((eq? x c) (set! cc (+ 1 cc)))
                               (else (assert #F)))
                         (let ((n (cdr x)))
                           (and (pair? n) n))))
           (cr (make-irregex-chunker u-get-next car))
           (ccr (counted-chunking-make-chunker cr))
           (c-get-next (chunker-get-next ccr)))
      (do ((z 100 (- z 1)))
          ((not (positive? z)))
        (let loop ((n i))
          (when n (loop (c-get-next n)))))
      (check (list ac bc cc) => '(1 2 101)))))


(define range-list-chunker/get-subchunk
  (make-irregex-chunker
   (chunker-get-next range-list-chunker)
   (chunker-get-str range-list-chunker)
   (chunker-get-start range-list-chunker)
   (chunker-get-end range-list-chunker)
   (chunker-get-substring range-list-chunker)
   (lambda (cnk1 start cnk2 end)
     (if (eq? cnk1 cnk2)
       (list (car cnk1) start end)
       (let loop ((c (cdddr cnk1))
                  (a (list (list (car cnk1) start (caddr cnk1)))))
         (if (eq? c cnk2)
           (apply append (reverse (cons (list (car c) (cadr c) end) a)))
           (loop (cdddr c)
                 (cons (list (car c) (cadr c) (caddr c)) a))))))))
(define ccr1
  (counted-chunking-make-chunker range-list-chunker/get-subchunk))

(define (icc0-ref n)
  (let loop ((cc icc0) (n n))
    (assert (counted-chunk? cc))
    (if (zero? n)
      cc
      (loop (counted-chunk-next cc) (- n 1)))))

(check (procedure? (chunker-get-subchunk ccr1)) => #T)
(let ((get-subchunk (chunker-get-subchunk ccr1)))
  (check ((all-positions ccr1)
          (get-subchunk icc0 6 (icc0-ref 4) 7))
         => '((4 0 4 0)
              (9 1 0 0)
              (16 1 7 0)
              (26 3 0 1)
              (51 5 4 0)))
  (check ((all-positions ccr1)
          (get-subchunk (icc0-ref 1) 0 (icc0-ref 2) 4))
         => '((9 1 0 0)
              (16 1 7 0)))
  (check ((all-positions ccr1)
          (get-subchunk (icc0-ref 3) 2 (icc0-ref 3) 7))
         => '((27 3 0 0)))
  (check ((all-positions ccr1)
          (get-subchunk (icc0-ref 3) 1 (icc0-ref 5) 7))
         => '((26 3 0 1)
              (51 5 4 0)
              (70 7 8 0)))
  (check ((all-positions ccr1)
          (get-subchunk (icc0-ref 9) 1 (icc0-ref 14) 1))
         => '((141 17 0 1)
              (152 18 0 0)
              (158 18 6 0)
              (159 19 0 0)
              (177 21 0 0)
              (200 24 0 1))))

;;;; counted-chunking-make-lose-refs

(define crlclr
  (counted-chunking-make-lose-refs range-list-chunking-lose-refs))
(define smc0
  (list (icc0-ref 2) (icc0-ref 13)
        (icc0-ref 2) (icc0-ref 4)
        #F #F
        (icc0-ref 4) (icc0-ref 4)
        #F #F
        (icc0-ref 3) (icc0-ref 9)
        (icc0-ref 7) (icc0-ref 13)))
(define smc0-lost
  (crlclr smc0))

(check (list? smc0-lost) => #T)
(check (length smc0-lost) => (length smc0))
(check (for-all (lambda (x t) (if t (counted-chunk? x) (not x)))
                smc0-lost
                '(cc cc cc cc #F #F cc cc #F #F cc cc cc cc))
       => #T)
(let* ((get-str (chunker-get-str ccr0))
       (get-str (lambda (x) (and x (get-str x)))))
  (check (for-all eq? (map get-str smc0-lost)
                      (map get-str smc0))
         => #T))
(let* ((get-start (chunker-get-start ccr0))
       (get-start (lambda (x) (and x (get-start x)))))
  (check (for-all eqv? (map get-start smc0-lost)
                       (map get-start smc0))
         => #T))
(let* ((get-end (chunker-get-end ccr0))
       (get-end (lambda (x) (and x (get-end x)))))
  (check (for-all eqv? (map get-end smc0-lost)
                       (map get-end smc0))
         => #T))
(check (for-all (lambda (x y) (or (not x) ((chunk-eqv? ccr0) x y)))
                smc0-lost smc0)
       => #T)
(check (for-all (lambda (x y) (or (not x) ((chunk-equal? ccr0) x y)))
                smc0-lost smc0)
       => #T)
(check (exists (lambda (x y) (and x (eq? x y)))
               smc0-lost smc0)
       => #F)
(check (for-all (lambda (x y)
                  (or (not x)
                      ((chunk-eqv? range-list-chunker)
                       (counted-chunk-underlying x) (counted-chunk-underlying y))))
                smc0-lost smc0)
       => #T)
(check (for-all (lambda (x y)
                  (or (not x)
                      ((chunk-equal? range-list-chunker)
                       (counted-chunk-underlying x) (counted-chunk-underlying y))))
                smc0-lost smc0)
       => #T)
(check (exists (lambda (x y)
                 (and x (eq? (counted-chunk-underlying x)
                             (counted-chunk-underlying y))))
               smc0-lost smc0)
       => #F)
(check (for-all (lambda (x y)
                  (or (not x)
                      (equal? (positions x) (positions y))))
                smc0-lost smc0)
       => #T)
(let ((get-subchunk (chunker-get-subchunk ccr1))
      (get-start (chunker-get-start ccr1))
      (ec (icc0-ref 13))
      (ei ((chunker-get-end ccr1) (icc0-ref 13))))
  (check (for-all (lambda (x y)
                    (or (not x)
                        (equal? ((all-positions ccr1) x)
                                ((all-positions ccr1)
                                 (get-subchunk y (get-start y) ec ei)))))
                  smc0-lost smc0)
         => #T))
(let ((make-last-chunk
       (lambda (get-next)
         (lambda (ic)
           (let loop ((c ic))
             (let ((n (get-next c)))
               (if n (loop n) c))))))
      (make-chain-list
       (lambda (get-next)
         (lambda (ic)
           (let loop ((c ic) (a '()))
             (if c
               (loop (get-next c) (cons c a))
               (reverse a)))))))
  (let* ((get-next (chunker-get-next ccr0))
         (last-chunk (make-last-chunk get-next))
         (chain-list (make-chain-list get-next)))
    (check (last-chunk (car smc0-lost)) (=> eq?) (cadr smc0-lost))
    (check (let ((chain-list (chain-list (car smc0-lost))))
             (for-all (lambda (x)
                        (or (not x)
                            (and (memq x chain-list) #T)))
                      smc0-lost))
           => #T))
  (let* ((get-next (chunker-get-next range-list-chunker))
         (last-chunk (make-last-chunk get-next))
         (chain-list (make-chain-list get-next)))
    (check (last-chunk (counted-chunk-underlying (car smc0-lost)))
           (=> eq?) (counted-chunk-underlying (cadr smc0-lost)))
    (check (let ((chain-list
                  (chain-list (counted-chunk-underlying (car smc0-lost)))))
             (for-all (lambda (x)
                        (or (not x)
                            (and (memq (counted-chunk-underlying x) chain-list) #T)))
                      smc0-lost))
           => #T)))
(check (eq? (list-ref smc0-lost 0) (list-ref smc0-lost 2)) => #T)
(check (eq? (list-ref smc0-lost 1) (list-ref smc0-lost 13)) => #T)
(check (eq? (list-ref smc0-lost 3) (list-ref smc0-lost 6)) => #T)
(check (eq? (list-ref smc0-lost 6) (list-ref smc0-lost 7)) => #T)
(let ((except
       (lambda (l i)
         (append (sublist l 0 i) (sublist l (+ 1 i))))))
  (check (memq (list-ref smc0-lost 10) (except smc0-lost 10)) => #F)
  (check (memq (list-ref smc0-lost 11) (except smc0-lost 11)) => #F)
  (check (memq (list-ref smc0-lost 12) (except smc0-lost 12)) => #F))

;;;; find-chunk/char

(define (text0-ref n)
  (let loop ((c text0) (n n))
    (if (zero? n)
      c
      (loop (cdddr c) (- n 1)))))

(let-syntax
    ((test
      (syntax-rules (=>)
        ((_ pos => chunk idx)
         (let-values (((c i) (find-chunk/char range-list-chunker text0 pos)))
           (check c (=> eq?) chunk)
           (check i => idx))))))
  (test 0 => (text0-ref 0) 2)
  (test 5 => (text0-ref 0) 7)
  (test 64 => (text0-ref 4) 13)
  (test 111 => (text0-ref 7) 3)
  (test 200 => (text0-ref 14) 0)
  (test 201 => #F #F)
  (test 202 => #F #F)
  (test 1234 => #F #F))

;;;; find-chunk/char/counted
;;;; line-column line-column/chunked line-column/chunked/counted

(check-values (find-chunk/char/counted ccr0 (icc0-ref 2) 5) => #F #F)
(check-values (find-chunk/char/counted ccr0 (icc0-ref 2) 15) => #F #F)

(let ((text1 "foo\nbar\rzab\r\nblah\fhohoho"))
  (let-syntax
      ((test
        (syntax-rules (=>)
          ((_ pos => l c)
           (check-values (line-column text1 pos) => l c)))))
    (test 0 => 0 0)
    (test 3 => 0 3)
    (test 4 => 1 0)
    (test 5 => 1 1)
    (test 6 => 1 2)
    (test 10 => 2 2)
    (test 12 => 2 #F)
    (test 13 => 3 0)
    (test 23 => 4 5)
    (test 24 => #F #F)
    (test 25 => #F #F) 
    (test 12345 => #F #F)))

(let ((icc0-2 (icc0-ref 2)) (icc0-2-start 16))
  (let-syntax
      ((test
        (syntax-rules (=>)
          ((_ pos => l c)
           (begin
             (check-values (line-column/chunked range-list-chunker text0 pos)
                           => l c)
             (if (negative? (- pos icc0-2-start))
               (check-values (line-column/chunked/counted ccr0 icc0-2 pos)
                             => #F #F)
               (check-values (line-column/chunked/counted ccr0 icc0-2 pos)
                             => l c))
             ;; NOTE: This does double-wrapped twice-counting.
             (check-values (line-column/chunked ccr0 icc0 pos)
                           => l c))))))
    (test 0 => 0 0)
    (test 8 => 0 8)
    (test 9 => 1 0)
    (test 16 => 1 7)
    (test 17 => 2 0)
    (test 26 => 2 #F)
    (test 28 => 3 1)
    (test 88 => 9 #F)
    (test 97 => 10 8)
    (test 141 => 16 #F)
    (test 194 => 23 3)
    (test 200 => 23 #F)
    (test 201 => #F #F)
    (test 202 => #F #F)
    (test 12345 => #F #F)))

;;;; find-chunk/line-column find-chunk/line-column/counted
;;;; char-of-line-column char-of-line-column/chunked char-of-line-column/chunked/counted

(let-syntax
    ((test
      (syntax-rules (=>)
        ((_ l col => chunk idx)
         (let-values (((c i)
                       (find-chunk/line-column range-list-chunker text0 l col)))
           (check c (=> eq?) chunk)
           (check i => idx))))))
  (test 0 0 => (text0-ref 0) 2)
  (test 0 1 => (text0-ref 0) 3)
  (test 0 8 => (text0-ref 0) 10)
  (test 0 9 => #F #F)
  (test 1 0 => (text0-ref 1) 0)
  (test 1 7 => (text0-ref 2) 3)
  (test 1 8 => #F #F)
  (test 2 0 => (text0-ref 2) 4)
  (test 2 9 => #F #F)
  (test 3 0 => (text0-ref 3) 2)
  (test 3 22 => #F #F)
  (test 5 2 => (text0-ref 3) 24)
  (test 5 5 => (text0-ref 4) 1)
  (test 7 3 => (text0-ref 4) 14)
  (test 7 10 => #F #F)
  (test 9 8 => (text0-ref 5) 18)
  (test 9 9 => #F #F)
  (test 23 8 => (text0-ref 13) 23)
  (test 24 0 => #F #F))

(check-values (find-chunk/line-column/counted ccr0 (icc0-ref 4) 1 2) => #F #F)
(check-values (find-chunk/line-column/counted ccr0 (icc0-ref 4) 5 3) => #F #F)

(let ((text1 "foo\nbar\rzab\r\nblah\fhohoho"))
  (let-syntax
      ((test
        (syntax-rules (=>)
          ((_ l col => c)
           (check (char-of-line-column text1 l col) => c)))))
    (test 0 0 => 0)
    (test 0 2 => 2)
    (test 0 4 => #F)
    (test 2 1 => 9)
    (test 2 4 => #F)
    (test 4 5 => 23)
    (test 4 6 => #F)))

(let-syntax
    ((test
      (syntax-rules (=>)
        ((_ l col => c)
         (check (char-of-line-column/chunked range-list-chunker text0 l col) => c)))))
  (test 0 0 => 0)
  (test 0 8 => 8)
  (test 0 9 => #F)
  (test 3 3 => 30)
  (test 5 7 => 54)
  (test 5 8 => #F)
  (test 9 9 => #F)
  (test 15 4 => 132)
  (test 19 50 => #F)
  (test 23 8 => 199)
  (test 24 0 => #F) 
  (test 24 1 => #F))

;;;; irregex-search/chunked/counting irregex-match/chunked/counting
;;;; counted-match-start-positions counted-match-end-positions

(let ((text1 '("Blah " "lala\nha" "ha\rcacaca 123\r" "\n456.")))
  (letrec-syntax
      ((test
        (lambda (stx)
          (syntax-case stx (=>)
            ((_ proc irx => ((sc sl scol) (ec el ecol)) ...)
             (with-syntax (((n ...) (enumerate #'(sc ...))))
               #'(let ((m (proc irx list-chunker text1)))
                   (begin (check-values (counted-match-start-positions m n)
                                        => sc sl scol)
                          (check-values (counted-match-end-positions m n)
                                        => ec el ecol))
                   ...)))
            ((_ proc irx => #F)
             #'(check (proc irx list-chunker text1) => #F)))))
       (test-s
        (syntax-rules () ((_ . r) (test irregex-search/chunked/counting . r))))
       (test-m
        (syntax-rules () ((_ . r) (test irregex-match/chunked/counting . r)))))
    (test-s #\B => ((0 0 0) (1 0 1)))
    (test-m '(* any) => ((0 0 0) (31 3 4)))
    (test-s '(+ (: (+ (: alpha #\a)) (+ (" \n\r")))) => ((5 0 5) (22 2 7)))
    (test-m '(: ($ (*? any)) ($ "ha") (*? any) ($ (+ num)) (* any))
            => ((0 0 0) (31 3 4))
               ((0 0 0) (10 1 0))
               ((10 1 0) (12 1 2))
               ((22 2 7) (25 2 10)))
    (test-s "nope" => #F)
    (test-m '(: #\A (* any)) => #F)
    (test-s "\n" => ((9 0 9) (10 1 0)))
    (test-s '(: any ($ "\r\n") any) => ((24 2 9) (28 3 1)) ((25 2 10) (27 3 0)))
    (test-s '(: ($ "\r") ($ "\n"))
            => ((25 2 10) (27 3 0))
               ((25 2 10) (26 2 #F))
               ((26 2 #F) (27 3 0)))))


(check-report)
