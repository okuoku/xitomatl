#!r6rs
;; Copyright (c) 2009 Derick Eddington.  All rights reserved.  Licensed under an
;; MIT-style license.  My license is in the file named LICENSE from the original
;; collection this file is distributed with.  If this file is redistributed with
;; some other collection, my license must also be included.

(import
  (rnrs)
  (srfi :78 lightweight-testing)
  (srfi :2 and-let*)
  (only (xitomatl irregex) irregex-match-substring
                           irregex-match-start-source irregex-match-start-index
                           irregex-match-end-source irregex-match-end-index)
  (only (xitomatl irregex extras) range-list-chunker)
  (xitomatl regexp))

;; TODO: SRE syntax/grammar errors

;;;; Basic aspects of all matchers

(let-syntax ((T (syntax-rules ()
                  ((_ sre str)
                   (check (and-let* ((m (regexp-match sre str)))
                            (irregex-match-substring m))
                          => str))))
             (F (syntax-rules ()
                  ((_ sre str)
                   (check (regexp-match sre str) => #F)))))
  (begin
    (T #\a "a")
    (F #\a "b")
    (F #\a ""))
  (begin
    (T "a" "a")
    (T "ab" "ab")
    (T "" "")
    (F "a" "b")
    (F "a" "")
    (F "ab" "ac")
    (F "ab" "a")
    (F "ab" "b")
    (F "ab" ""))
  (begin
    (T '(/ #\a #\z #\A #\Z #\0 #\9) "d")
    (T '(/ #\a #\z #\A #\Z #\0 #\9) "D")
    (T '(/ #\a #\z #\A #\Z #\0 #\9) "4")
    (F '(/ #\a #\z #\A #\Z #\0 #\9) "%")
    (F '(/ #\a #\z #\A #\Z #\0 #\9) "")
    (F '(/) "d"))
  (begin
    (T '(~) "a")
    (T '(~ #\a) "b")
    (T '(~ #\a #\b) "c")
    (T '(~ #\a #\b #\d) "c")
    (T '(~ (~ #\a)) "a")
    (F '(~) "")
    (F '(~ #\a) "a")
    (F '(~ #\a #\b #\d) "d")
    (F '(~ #\a #\b #\d) "")
    (F '(~ (or #\a #\b #\d)) "d")
    (F '(~ (~ (~ #\a))) "a"))
  (begin
    (T '(& #\a) "a")
    (T '(& (/ #\a #\z) #\z) "z")
    (T '(& (/ #\d #\f) (/ #\a #\z)) "e")
    (T '(& (/ #\a #\z) (/ #\c #\x) (/ #\f #\q)) "o")
    (F '(&) "a")
    (F '(& #\a) "")
    (F '(& #\a) "b")
    (F '(& (/ #\a #\z) #\z) "a")
    (F '(& (/ #\d #\f) (/ #\a #\z)) "g")
    (F '(& (/ #\a #\z) (/ #\c #\x) (/ #\f #\q)) "e"))
  (begin
    (T '(- #\a) "a")
    (T '(- (~ #\a) (/ #\d #\f)) "c")
    (T '(- (/ #\a #\z) #\g #\q #\y) "x")
    (F '(-) "a")
    (F '(- #\a) "")
    (F '(- (~ #\a) (/ #\d #\f)) "a")
    (F '(- (~ #\a) (/ #\d #\f)) "e")
    (F '(- (/ #\a #\z) #\g #\q #\y) "g")
    (F '(- (/ #\a #\z) #\g #\q #\y) "q")
    (F '(- (/ #\a #\z) #\g #\q #\y) "y")
    (F '(- (/ #\a #\z) (or #\c #\k #\w)) "k"))
  (begin
    (T '(:) "")
    (T '(: #\a) "a")
    (T '(: "fo" #\o #\b "ar") "foobar")
    (T '(: (:) #\f (: "oo" (:) (: #\b) #\a) #\r (:)) "foobar")
    (F '(: #\a) "b")
    (F '(: "fo" #\o #\b "ar") "fobbar")
    (F '(: (:) #\f (: "oo" (:) (: #\b) #\a) #\r (:)) "fobbar"))
  (begin
    (T '(or #\a) "a")
    (T '(or #\a #\b) "b")
    (T '(or "foo" #\b (or "ar" "bar")) "bar")
    (F '(or) "a")
    (F '(or #\a) "b")
    (F '(or "foo" (or "ar" "bar")) "zab"))
  (begin
    (T '(*) "")
    (T '(* #\a) "")
    (T '(* #\a) "a")
    (T '(* #\a) "aa")
    (T '(* #\a) "aaaaa")
    (T '(* #\f #\o #\o "bar") "foobarfoobar")
    (T '(: (* (~)) "foo") "aaaafoo")
    (T '(: (* (~)) "foo") "foo")
    (F '(* #\a) "aaaba")
    (F '(* #\f #\o #\o "bar") "foobar foobar"))
  (begin
    (T '(*?) "")
    (T '(*? #\a) "")
    (T '(*? #\a) "a")
    (T '(*? #\a) "aa")
    (T '(*? #\a) "aaaaa")
    (T '(*? #\f #\o #\o "bar") "foobarfoobar")
    (T '(: (*? (~)) "foo") "aaaafoo")
    (T '(: (*? (~)) "foo") "foo")
    (F '(*? #\a) "aaaba")
    (F '(*? #\f #\o #\o "bar") "foobar foobar"))
  (begin
    (T '(+) "")
    (T '(: (+ (~)) "foo") "afoo")
    (F '(+ #\a) "")
    (F '(: (+ (~)) "foo") "foo"))
  (begin
    (T '(>=? 1) "")
    (T '(: (>=? 1 (~)) "foo") "afoo")
    (F '(>=? 1 #\a) "")
    (F '(: (>=? 1 (~)) "foo") "foo"))
  (begin
    (T '(?) "")
    (T '(? #\a) "")
    (T '(? #\a) "a")
    (T '(? #\a #\b "foo") "")
    (T '(? #\a #\b "foo") "abfoo")
    (T '(: (? #\a) #\b (? #\c)) "b")
    (T '(: (? #\a) #\b (? #\c)) "ab")
    (T '(: (? #\a) #\b (? #\c)) "bc")
    (T '(: (? #\a) #\b (? #\c)) "abc")
    (T '(: (? #\a) "ab") "ab")
    (T '(: (? #\a) "ab") "aab")
    (F '(?) "a")
    (F '(? #\a) "aa")
    (F '(? #\a) "b")
    (F '(? #\a #\b "foo") "abgoo")
    (F '(: (? #\a) #\b (? #\c)) "a")
    (F '(: (? #\a) #\b (? #\c)) "ac")
    (F '(: (? #\a) "ab") "aaab"))
  (begin
    (T '(??) "")
    (T '(?? #\a) "")
    (T '(?? #\a) "a")
    (T '(?? #\a #\b "foo") "")
    (T '(?? #\a #\b "foo") "abfoo")
    (T '(: (?? #\a) #\b (?? #\c)) "b")
    (T '(: (?? #\a) #\b (?? #\c)) "ab")
    (T '(: (?? #\a) #\b (?? #\c)) "bc")
    (T '(: (?? #\a) #\b (?? #\c)) "abc")
    (T '(: (?? #\a) "ab") "ab")
    (T '(: (?? #\a) "ab") "aab")
    (F '(??) "a")
    (F '(?? #\a) "aa")
    (F '(?? #\a) "b")
    (F '(?? #\a #\b "foo") "abgoo")
    (F '(: (?? #\a) #\b (?? #\c)) "a")
    (F '(: (?? #\a) #\b (?? #\c)) "ac")
    (F '(: (?? #\a) "ab") "aaab"))
  (begin
    (T '(= 2 #\a) "aa")
    (T '(= 2 (or "ab" #\a) (or #\b #\c)) "ababc")
    (T '(= 2 (or "ab" #\a) (or #\a #\b #\c)) "abac")
    (F '(= 2 #\a) "a")
    (F '(= 2 #\a) "aaa")
    (F '(= 2) ""))
  (begin
    (T '(>= 2 #\a) "aa")
    (T '(>= 2 #\a) "aaa")
    (T '(: (>= 2 #\a) (= 3 #\a)) "aaaaa")
    (T '(: (>= 2 #\a) (= 3 #\a)) "aaaaaaa")
    (F '(>= 3 #\a) "aa")
    (F '(>= 2) "")
    (F '(: (>= 2 #\a) (= 3 #\a)) "aaaa"))
  (begin
    (T '(>=? 2 #\a) "aa")
    (T '(>=? 2 #\a) "aaa")
    (T '(: (>=? 2 #\a) (= 3 #\a)) "aaaaa")
    (T '(: (>=? 2 #\a) (= 3 #\a)) "aaaaaaa")
    (F '(>=? 3 #\a) "aa")
    (F '(>=? 2) "")
    (F '(: (>=? 2 #\a) (= 3 #\a)) "aaaa"))
  (begin
    (T '(** 2 4 #\a) "aa")
    (T '(** 2 4 #\a) "aaa")
    (T '(** 2 4 #\a) "aaaa")
    (F '(** 2 4) "")
    (F '(** 2 4 #\a) "a")
    (F '(** 2 4 #\a) "aaaaa"))
  (begin
    (T '(**? 2 4 #\a) "aa")
    (T '(**? 2 4 #\a) "aaa")
    (T '(**? 2 4 #\a) "aaaa")
    (F '(**? 2 4) "")
    (F '(**? 2 4 #\a) "a")
    (F '(**? 2 4 #\a) "aaaaa"))
  (begin
    (T '(: "foo" (look-ahead #\b "ar") (* any)) "foobar")
    (T '(: (look-ahead bos) "foobar" (look-ahead eos)) "foobar")
    (F '(: "foo" (look-ahead "zabbo") (* any)) "foobar"))
  (let ((M (lambda (o i b r k) (if (even? i) (k o (+ 1 i)) (k #F #F)))))
    (T M "a")
    (F `(: ,M ,M) "aa"))
  (begin
    (F #F "")
    (F #F "a")
    (F '(: #\a #\b #F #\c) "abc")
    (T '(or #\a #F #\b #F #\c) "c"))
  (begin
    (T 'any "a")
    (T '(* any) "abcdefg")
    (T '(- any (/ #\a #\z)) "Î»")
    (F 'any "")
    (F '(~ any) "a")
    (F '(- any (/ #\a #\z)) "d")
    (F '(- any any) "a"))
  (begin
    (T 'nonl "a")
    (for-each (lambda (str) (F 'nonl str))
              '("\xA;" "\xD;" "\x85;" "\xC;" "\x2028;" "\x2029;"))))

;; TODO: regexp-match is anchored at beginning and end

;;;; 'bos failures prevent searching from advancing unnecessarily

(let ((M (lambda (sre)
           (let ((m (compile-SRE sre))
                 (count 0))
             (case-lambda
               ((o i b r k)
                (set! count (+ 1 count))
                (m o i b r k))
               (() count))))))
  (let-syntax
      ((test (syntax-rules (=>)
               ((_ sre str => r count)
                (let ((m (M sre)))
                  (check (and (regexp-search m str) #T) => r)
                  (check (m) => count))))))
    (test '#\d "abcdef" => #T 4)
    (test '(: bos #\d) "abcdef" => #F 2)
    (test '(: "ab" bos) "abcdef" => #F 1)
    (test '(or (: bos #\c) (: bos #\b) (: bos #\a)) "abcdef" => #T 1)
    (test '(: #\a (or (: bos #\d) (: bos #\c) (: bos #\b))) "abcdef" => #F 1)
    (test '(: #\a (or (: bos #\d) #\c (: bos #\b))) "abcdef" => #F 7)
    (test '(: #\a (or #\c #\d #\b) bos #\c) "abcdef" => #F 1)
    (test '(: (look-ahead bos) "blah") "abcdef" => #F 2)
    #;(test '(: #\a (or "c" "d" "b") bos #\c) "abcdef" => #F 1)))

;;;; Chunking

(let* ((text '("xx" 1 1 "xxThix" 2 5 "s" 0 1 " is a chxx" 0 8
               "xxxun" 3 5 "xked senx" 1 8 "xxten" 2 5 "ce." 0 3))
       (text-ref
        (lambda (i)
          (let loop ((i i) (t text))
            (if (= 0 i)
              t
              (loop (- i 1) (cdddr t)))))))
  (let-syntax
      ((test (syntax-rules (=>)
               ((_ sre => mt so si eo ei)
                (let ((m (regexp-search/chunked sre range-list-chunker text)))
                  (check (and m #T) => #T)
                  (check (irregex-match-substring m) => mt)
                  (check (irregex-match-start-source m 0) (=> eq?) so)
                  (check (irregex-match-start-index m 0) => si)
                  (check (irregex-match-end-source m 0) (=> eq?) eo)
                  (check (irregex-match-end-index m 0) => ei))))))
    (test '(* any)
          => "This is a chunked sentence."
             (text-ref 1) 2 (text-ref 7) 3)
    (test '(*? any)
          => "" (text-ref 1) 2 (text-ref 1) 2)
    (test '(: bos (+ (/ #\a #\z #\A #\Z)) (+ #\space))
          => "This " (text-ref 1) 2 (text-ref 3) 1)
    (test '(: (+ (~ #\space)) eos)
          => "sentence." (text-ref 5) 5 (text-ref 7) 3)
    (test '(: (or "blah" (: (or #\H #\h) "is"))
              (+ (~ (~ #\space)))
              (& (or #\x #\i #\A) (or #\Z #\i #\x)) (or "S" "s")
              (*? any) (- any #\space)
              (* any) (or "ked" "sen") "te"
              (look-ahead "nc" (~ (- any #\e)) (or "blah" #\.) eos))
          => "his is a chunked sente"
             (text-ref 1) 3 (text-ref 6) 4)))


(check-report)
